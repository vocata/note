# 函数

## 函数签名

```rust
// add为函数名，lhs和rhs为函数形参，-> i32表示函数返回值类型
fn add(lhs: i32, rhs: i32) -> i32 {
    lhs + rhs   // 函数体
}
```

## 函数返回

和其他语言不同的是，rust的函数返回可以不用写return语句，但是要求最后执行的必须为表达式，表达式返回值就是函数的返回值，例如

```rust
fn sub(lhs: i32, rhs: i32) -> i32 {
    lhs - rhs
}
```

当然，也可以显式的使用return语句返回函数值，这通常用于函数的提前返回，例如

```rust
fn compare_and_add(x: i32) -> i32 {
    if x == 0 {
        return x;
    }
    
    x + 5;
}
```

对于没有返回值的函数，实际上rust会隐式增加返回值()，也就是说会默认返回一个单元类型值，例如

```rust
fn print_num(x: i32) {
    println!("{}", x);
}

let result = print_num(10); // result等于()
```

上面代码等价于

```rust
fn print_num(x: i32) -> () {
    println!("{}", x);
    return ();
}

let result = print_num(10); // result等于()
```

## 发散函数（diverging function）

使用!作为函数的返回类型的函数被称为发散函数，这种函数永远不会返回，通常还未实现具体功能函数可以先定义为发散函数，当执行到该函数时直接panic掉

```rust
fn cal_result(x: i32) -> ! {
    unimplemented!()
}
```

另外，在一些特殊场景下，需要启动一个无限循环来执行某些后台任务的时候，也可以使用发散函数

```rust
fn heartbeat() -> ! {
    loop {
        // 定时发送心跳消息
    }
}
```
