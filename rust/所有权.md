# 所有权

> 变量即内存对象，变量名是抽象的内存对象标识符，在底层机器码中不会存在
> 值即内存对象中存在的内容

## 所有权原则

- 每个值都被一个变量所拥有，该变量为值的所有者
- 一个值只能被一个变量所拥有，一个变量也只能绑定一个值
- 当所有者离开作用域是，这个值将会被drop

## 拷贝

拷贝实际上是一种转移内存的技术，其中分为浅拷贝和深拷贝

- 浅拷贝：只拷贝栈中的对象，基础类型间的拷贝都是浅拷贝
- 深拷贝：一般来说对对象中指针变量指向的内存进行拷贝的操作都认为是深拷贝

由于深拷贝对性能的影响较大，所以rust默认不会采用深拷贝。

## 移动（move）语义

当一个变量给另外一个变量赋值时，在rust中是执行的是移动操作，移动后的变量将会失去值的所有权，失去所有权的变量在离开作用域的时候不会执行drop操作，保证了变量离开作用于后不会重复释放内存。而rust的移动操作实际上就是做浅拷贝，唯一的区别是移动后的对象将会被置为无效，任何使用移动后的对象都会编译报错，移动语义保证了值和所有者一一对应的关系

实现了Copy特征（通常是深拷贝）的类型在赋值时不会执行移动操作，因此在赋值后原本的对象仍保有值的所有权。rust的基本类型都实现了Copy特征，因此他们之间可以的相互赋值而不会导致源对象失效

> - 实际上rust中的所有权可以理解是从语言层面上实现了c++中的move语义，但c++不会在编译期检测对象是否被移动，虽然c++标准要求移动后的对象是无效的，不能够再被使用，但是并没有在编译期限制，需要程序员保证不使用移动后对象。而rsut则是在编译器做了检测，使用了移动后的对象将会在编译器就报错，从根本上保证了移动语义的安全性
> - 基础类型在离开作用域时也不会执行drop操作，或者说执行一个空的drop操作，取决于编译器的实现
> - 可变引用没有实现Copy特征，因此它算是唯一一个在赋值时执行移动语义的基本类型

## 部分move

可以同时对一个变量的某些部分执行move或引用解构，当其中某些部分使用move方式解构变量后，则变量中的这部分的所有权将会转移，称为部分move，这种情况下，原有的变量将无法使用

```rust
let a = (String::from("hello"), String::from("world"));
let (b, ..) = a;
// println!("{:?}", a);    // error，a已经部分move
```

但是对于变量中某些所有权没有发生转移的部分（例如使用引用解构），还是可以继续使用的

```rust
let a = (String::from("hello"), String::from("world"));
let (b, ref c) = a;
// println!("{:?}", a);    // error，a已经部分move
println!("{}", a.1);
```

