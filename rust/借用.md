# 借用

## 引用

获取变量的引用，在rust中称为借用（borrow）。rust中引用的概念可以类比于c++中的指针，借用并没有获取对象的拥有权，因此在离开作用域的时候并不会丢弃（drop）被借用对象的内容

- 在引用的作用域内，不能存在多个可变引用，主要是避免数据竞争
- 在引用的作用域内，不能同时可变引用和不可变引用，主要是避免不可变引用读到脏数据
- rust保证了引用总是有效的，如果引用了一个drop的对象，编译器会报错，这避免了c++中的悬垂指针问题的发生

> NOTE：引用的作用域和变量的作用域不同，变量的作用是用创建开始一直到语句块的结束（花括号}的位置），而引用的作用域是从其创建开始到最后一次使用的地方

## 引用语法

有两种获取引用的方法：&运算符和ref关键字，两者是等价的，只是使用方法上略有不同，使用ref关键字时编译器会自动将变量声明为引用，并自动获取右值的引用。

```rust
let a = 3;

// &运算符，b被推导为&i32类型
let b = &a;
// ref关键字，无需显式调用&运算符，编译器会自动获取a的引用并赋予b，b的类型为&i32
let ref b = a;
```

对于可变引用，要注意两者的写法的区别

```rust
let mut a = 1;

// 使用&运算符
let b = &mut a; // b的类型为&mut i32
// 使用ref关键字
let ref mut b = a;
```

另外，在解构时，有些情况只能使用ref关键字来获取引用

```rust
let tup = (1, 2);
// 元组解构时，令其中一个为引用
// let (a, b) = tup; // a: i32, b: i32
// let (a, b): (i32, &i32) = tup; // 报错，tup.1并不是&i32类型
let (a, ref b) = tup;    // 成功，b被声明为引用类型，并自动获取元组(1, 2).1的引用
```

```rust
struct Person {
    name: String,
    age: Box<u8>,
};

let person = Person {
    name: String::from("Alice"),
    age: Box::new(20),
};

let Person { name, ref age } = person;  // 部分move，age被声明为引用类型，并自动获取person.age的引用
```

## 字面量的引用

对字面的引用时，编译器会自动闯将一个临时变量，并将指针指向该临时量（和c++的右值引用的效果类似）

```rust
// &运算符
let a = &mut 3; // a: &mut i32
// ref关键字
let ref mut a = 3;  // a: &mut i32
```

