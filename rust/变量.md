# 变量

## 变量绑定

```rust
let num = 3;
let msg = "hello world";
```

变量绑定过程：

1. 分配内存
2. 编译器将变量绑定的分配的内存块，作为分配内存块的唯一标识符
3. 变量初始化，也就是将值赋给分配的内存块

只有满足上述三个过程，编译器才会认为变量绑定完成，否则就会报错。其中前两部是在let语句的时候就完成了，变量初始化则可以单独完成，例如：

```rust
let s;
s = String::from("hello world");
```

> NOTE：不允许使用未初始化的变量

## 变量类型

### 数值运算

1. 浮点数类型只实现了std::cmp::PartialEq，没有实现std::cmp::Eq，因此不能作为HashMap的key
2. 同数值类型之间才能做运算
3. 字面值不显式指定类型的话，默认为i32或f64
3. rust中类型推导是符合直觉的，在使用时变量类型会根据上下文推导出来，比如
    ```rust
    // 为保证运算能够执行下去，one和three均会推导为i64类型
    let one = 1;
    let two: i64 = 2;
    let three = one + two;

    // list会推导为f32类型的数组
    let list = [42., 42f32, 42.0]
    ```
4. 虽然整型和浮点数有默认推导类型（i32和f64），但在使用时，需要能明确推导出其类型，否则rust会直接报错，比如
    ```rust
    // 所有整型都有pow方法，无法推导出实际的整型类型，存在二义性，报错
    let three = 3;
    three.pow(2);

    // 所有整型都有pow方法，无法推导出实际的浮点数类型，存在二义性，报错
    let four = 3.0f64;
    four.round();
    ```
5. rust永远不会做隐式转换
    ```rust
    // 将字面值整型3初始化f32类型的变量，报错
    let one: f32 = 3;
    // 42为字面值整型，42f32为显示f32类型，存在二义性，报错
    let list = [42, 42f32];
    ```

### 字符类型

rust中的字符类型占用4个字节，可以存储一个unicode字符

### 布尔类型

rust中布尔类型占用1个字节，主要用于条件判断

### 单元类型

rust中的单元类型为()，唯一的取值也是()，**不占用内存**。在rust中没有没有显示定义返回值的函数返回的都是()，如main函数和println!宏返回的都是()。另外，单元类型可以用作map的值，其作用类似于go语言中的struct{}
